#include <Arduino.h>
#include <PS4Controller.h>


TaskHandle_t Rstep;
TaskHandle_t Lstep;
void WriteStepsL(void *pvParameters);
void WriteStepsR(void *pvParameters);
void drive(int isRight, int stepPin, int dirPin);

#define MAX_STEP_DELAY 1000 // Max microseconds per step (slowest speed)
#define MIN_STEP_DELAY 500 // Min microseconds per step (fastest speed)

#define DEADZONE_SIZE 15

#define MOTOR_R_DIRECTION 1 // Set to -1 to reverse motor direction, instead of rewiring
#define MOTOR_L_DIRECTION 1 

#define DIR_R 14 // Direction pin for Right motors
#define DIR_L 32 // Direction pin for Left motors
#define STEP_R 27 // Step pin for Right motors
#define STEP_L 26 // Step pin for Left motors



void setup()
{
  
  delay(1000);
  
  // Connect PS4 controller
  Serial.begin(115200);
  char bluetoothMAC[] = "01:02:03:04:05:06";
  PS4.begin(bluetoothMAC);

  xTaskCreatePinnedToCore(
        WriteStepsR, 
        "Write Right steps", 
        10000,
        NULL,
        1,
        &Rstep,
        0);

  xTaskCreatePinnedToCore(
        WriteStepsL, 
        "Write Left steps", 
        10000,
        NULL,
        1,
        &Lstep,
        1);

}

void WriteStepsL(void *pvParameters)
{
  drive(0, STEP_L, DIR_L);
}

void WriteStepsR(void *pvParameters)
{
  drive(1, STEP_R, DIR_R);
}

void drive(int isRight, int stepPin, int dirPin)
{
  while(1)
  {
    int stickVal = 0, delayTime = 0;
    if(!PS4.isConnected())
    {
      Serial.println("Waiting to connect to controller...");
      delay(100);
    }
    else
    {
      // If the controller is connected, calculate
      // a delayTime from the stick

      // Get the correct stick's y value
      if(isRight)
        stickVal = PS4.data.analog.stick.ry;
      else
        stickVal = PS4.data.analog.stick.ly;

      // Establish direction
      // This allows the user to reverse the direction of the left or right motors in software.
      // The isRight conditional allows drive() to be used for either side
      if (stickVal * (isRight ? MOTOR_R_DIRECTION : MOTOR_L_DIRECTION) > 0)
        digitalWrite(dirPin, HIGH);
      else
        digitalWrite(dirPin, LOW);

      // Convert the stick position to a magnitude
      // stickVal may be a value -128 to 127, we want 0 to 127
      // If it's negative, we add 1 to make the range 0 to 127 instead of 1 to 128
      if (stickVal < 0)
        stickVal = (int) abs(stickVal + 1);
      
      // Calculate deadzone
      if (stickVal < DEADZONE_SIZE)
        stickVal = 0;

      // Map stick magnitudes to stepper delays (high stick value -> low delay, low stick value -> high delay)
      delayTime = map(max(stickVal, DEADZONE_SIZE), DEADZONE_SIZE, 128, MAX_STEP_DELAY, MIN_STEP_DELAY);

      // Execute step if stick is outside deadzone
      // Serial.print("Delay: ");
      // Serial.print(delayTime);
      // Serial.print(" StickValue: ");
      // Serial.println(stickVal);
      stickVal=1;
      if(stickVal != 0)
      {
        //Serial.print("XO");
        digitalWrite(stepPin, HIGH);
        delayMicroseconds(500);
        digitalWrite(stepPin, LOW);
        delayMicroseconds(500);
      }
    }


    
    vTaskDelay(1);
  }
}

void loop()
{
  
}